function  [dc, ds] = DistanceToConstraint(ds, pa, depth_range)

% simulate VR flow scene to generate distance to constraint for multiple velocities
% takes saved variables from VR experiment

seed=2;
rng(seed) % to have random dots that appear in the same "random" place each time
ns = pa.targetMotionDuration; % number of seconds
world_speed = pa.translation; % m/s speed of the observer in a straight line
fps = ds.frameRate; %Screen(screenNumber,'FrameRate'); % should be 144 to match experiment

 
height = -pa.floorHeight;

speeds =  pa.speed;
directions = pa.direction ; 

conditions = fullfact([numel(speeds), numel(directions)]); 

if ~isfield(pa,objectdist)
    object_dist = 2;
    fixation = 3;
else
    object_dist = pa.objectdist;
    fixation = pa.fixationdist;
end

if depth_range == 0
    calculate_segment = 0; % calculate to segment or point (0)
else
    calculate_segment = 1;
end

dim = [pa.floorWidth,0,pa.floorWidth]; % extent of where dots can be in m: X, Y, Z. Depth is more than how far you're travelling (ns *speed) + a little extra 
% 5 m across
nClusters = 1000; % specify number of clusters
nDotsPerCluster = 1;% number of dots per cluster
nObjects = 50;
 
% *** find these based on oculus display
view_dist = .5; %m how far the screen is from the observer
viewingdepths = [.01,   5]; % nearest and furthest dots that can show up, m
 
windowRect = [0           0        2560    1600]; % screen size in pixels (origin, width of screen, height of screen)
pixels = windowRect(3:4); % pixel width and height of screen
screensize = [.712 .312]; % screen size in m
 
ppcm = [39,39]; % pixel per cm of the screen
xyrat = windowRect(3)/windowRect(4);
 
clusters = rand(nClusters,3).*dim - [.5*dim(1), .5*dim(2)-height, 0]; % randomize position of dots, centered around x = 0, and ground pushed down
% [.5*dim(1), -height, 0];
 
%object positions
positions = -dim(1)/2+2*dim(1)/2*rand(nObjects,2); %uniform random positions across floor
positions(:,2) = positions(:,2)+ds.fixationdist;
 
dots = repmat(clusters,nDotsPerCluster,1); % ground plane
% for no floor
% dots = [];

object = [.075, .075, .075]; %length, width, height
dotsperobj = 15;
a = -object(1);
b = object(1);
aboveground = -.15;%-.1;
 
if ~isempty(nObjects)
    for obj = 1:nObjects
        r = (b-a).*rand(dotsperobj,3) + a;
        newpositions = [r(:,1)+positions(obj,1), r(:,2)+(height-b), r(:,3)+positions(obj,2)];
        dots = [dots; newpositions];
    end
end
            
fixation_dot = [0, height, dim(3)/2];
dots(end+1,:) = fixation_dot;
fixation_idx = length(dots);
